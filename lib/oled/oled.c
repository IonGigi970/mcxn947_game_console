/**
 * @file oled.c
 * @brief OLED Display Driver for SSD1306 128x64
 * 
 * This file contains the OLED display driver implementation.
 * Font data and display functions for I2C OLED.
 * 
 * @note Original library provided by NXP for educational purposes.
 * @note Modified and extended for MCXN947 Game Console project.
 * 
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include <stdint.h>
#include "stdbool.h"
#include "stdarg.h"
#include <stdio.h>
#include <string.h>
#include "board.h"
#include "peripherals.h"
#include "pin_mux.h"
#include "clock_config.h"
#include "MCXN947_cm33_core0.h"
#include "fsl_debug_console.h"
#include "fsl_lpi2c.h"
#include "oled.h"

uint8_t currCharLoc[2] = {0, 0}; // curCharLoc[0] = current char within a page (0-21), curCharLoc[1] = current page (0-7)

const char font[256][6]={
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x00,   0
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x01,   1
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x02,   2
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x03,   3
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x04,   4
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x05,   5
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x06,   6
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x07,   7
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x08,   8
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x09,   9
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x0A,  10
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x0B,  11
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x0C,  12
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x0D,  13
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x0E,  14
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x0F,  15
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x10,  16
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x11,  17
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x12,  18
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x13,  19
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x14,  20
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x15,  21
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x16,  22
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x17,  23
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x18,  24
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x19,  25
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x1A,  26
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x1B,  27
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x1C,  28
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x1D,  29
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x1E,  30
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x1F,  31
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x20,  32, ( )
		{0x00, 0x00, 0x06, 0x5F, 0x06, 0x00}, // Char 0x21,  33, (!)
		{0x00, 0x07, 0x03, 0x00, 0x07, 0x03}, // Char 0x22,  34, (")
		{0x00, 0x24, 0x7E, 0x24, 0x7E, 0x24}, // Char 0x23,  35, (#)
		{0x00, 0x24, 0x2B, 0x6A, 0x12, 0x00}, // Char 0x24,  36, ($)
		{0x00, 0x63, 0x13, 0x08, 0x64, 0x63}, // Char 0x25,  37, (%)
		{0x00, 0x36, 0x49, 0x56, 0x20, 0x50}, // Char 0x26,  38, (&)
		{0x00, 0x00, 0x07, 0x03, 0x00, 0x00}, // Char 0x27,  39, (')
		{0x00, 0x00, 0x3E, 0x41, 0x00, 0x00}, // Char 0x28,  40, (()
		{0x00, 0x00, 0x41, 0x3E, 0x00, 0x00}, // Char 0x29,  41, ())
		{0x00, 0x28, 0x10, 0x7C, 0x10, 0x28}, // Char 0x2A,  42, (*)
		{0x00, 0x08, 0x08, 0x3E, 0x08, 0x08}, // Char 0x2B,  43, (+)
		{0x00, 0x00, 0xE0, 0x60, 0x00, 0x00}, // Char 0x2C,  44, (,)
		{0x00, 0x08, 0x08, 0x08, 0x08, 0x08}, // Char 0x2D,  45, (-)
		{0x00, 0x00, 0x60, 0x60, 0x00, 0x00}, // Char 0x2E,  46, (.)
		{0x00, 0x20, 0x10, 0x08, 0x04, 0x02}, // Char 0x2F,  47, (/)
		{0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E}, // Char 0x30,  48, (0)
		{0x00, 0x00, 0x42, 0x7F, 0x40, 0x00}, // Char 0x31,  49, (1)
		{0x00, 0x62, 0x51, 0x49, 0x49, 0x46}, // Char 0x32,  50, (2)
		{0x00, 0x21, 0x41, 0x45, 0x4B, 0x31}, // Char 0x33,  51, (3)
		{0x00, 0x18, 0x14, 0x12, 0x7F, 0x10}, // Char 0x34,  52, (4)
		{0x00, 0x2F, 0x49, 0x49, 0x49, 0x31}, // Char 0x35,  53, (5)
		{0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30}, // Char 0x36,  54, (6)
		{0x00, 0x03, 0x71, 0x09, 0x05, 0x03}, // Char 0x37,  55, (7)
		{0x00, 0x36, 0x49, 0x49, 0x49, 0x36}, // Char 0x38,  56, (8)
		{0x00, 0x06, 0x49, 0x49, 0x29, 0x1E}, // Char 0x39,  57, (9)
		{0x00, 0x00, 0x6C, 0x6C, 0x00, 0x00}, // Char 0x3A,  58, (:)
		{0x00, 0x00, 0xEC, 0x6C, 0x00, 0x00}, // Char 0x3B,  59, (;)
		{0x00, 0x08, 0x14, 0x22, 0x41, 0x00}, // Char 0x3C,  60, (<)
		{0x00, 0x24, 0x24, 0x24, 0x24, 0x24}, // Char 0x3D,  61, (=)
		{0x00, 0x00, 0x41, 0x22, 0x14, 0x08}, // Char 0x3E,  62, (>)
		{0x00, 0x02, 0x01, 0x59, 0x09, 0x06}, // Char 0x3F,  63, (?)
		{0x00, 0x32, 0x49, 0x79, 0x41, 0x3E}, // Char 0x40,  64, (@)
		{0x00, 0x7E, 0x11, 0x11, 0x11, 0x7E}, // Char 0x41,  65, (A)
		{0x00, 0x7F, 0x49, 0x49, 0x49, 0x36}, // Char 0x42,  66, (B)
		{0x00, 0x3E, 0x41, 0x41, 0x41, 0x22}, // Char 0x43,  67, (C)
		{0x00, 0x7F, 0x41, 0x41, 0x41, 0x3E}, // Char 0x44,  68, (D)
		{0x00, 0x7F, 0x49, 0x49, 0x49, 0x41}, // Char 0x45,  69, (E)
		{0x00, 0x7F, 0x09, 0x09, 0x09, 0x01}, // Char 0x46,  70, (F)
		{0x00, 0x3E, 0x41, 0x49, 0x49, 0x3A}, // Char 0x47,  71, (G)
		{0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F}, // Char 0x48,  72, (H)
		{0x00, 0x00, 0x41, 0x7F, 0x41, 0x00}, // Char 0x49,  73, (I)
		{0x00, 0x20, 0x40, 0x41, 0x3F, 0x01}, // Char 0x4A,  74, (J)
		{0x00, 0x7F, 0x08, 0x14, 0x22, 0x41}, // Char 0x4B,  75, (K)
		{0x00, 0x7F, 0x40, 0x40, 0x40, 0x40}, // Char 0x4C,  76, (L)
		{0x00, 0x7F, 0x02, 0x04, 0x02, 0x7F}, // Char 0x4D,  77, (M)
		{0x00, 0x7F, 0x02, 0x04, 0x08, 0x7F}, // Char 0x4E,  78, (N)
		{0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E}, // Char 0x4F,  79, (O)
		{0x00, 0x7F, 0x09, 0x09, 0x09, 0x06}, // Char 0x50,  80, (P)
		{0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E}, // Char 0x51,  81, (Q)
		{0x00, 0x7F, 0x09, 0x09, 0x19, 0x66}, // Char 0x52,  82, (R)
		{0x00, 0x26, 0x49, 0x49, 0x49, 0x32}, // Char 0x53,  83, (S)
		{0x00, 0x01, 0x01, 0x7F, 0x01, 0x01}, // Char 0x54,  84, (T)
		{0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F}, // Char 0x55,  85, (U)
		{0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F}, // Char 0x56,  86, (V)
		{0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F}, // Char 0x57,  87, (W)
		{0x00, 0x63, 0x14, 0x08, 0x14, 0x63}, // Char 0x58,  88, (X)
		{0x00, 0x07, 0x08, 0x70, 0x08, 0x07}, // Char 0x59,  89, (Y)
		{0x00, 0x61, 0x51, 0x49, 0x45, 0x43}, // Char 0x5A,  90, (Z)
		{0x00, 0x00, 0x7F, 0x41, 0x41, 0x00}, // Char 0x5B,  91, ([)
		{0x00, 0x02, 0x04, 0x08, 0x10, 0x20}, // Char 0x5C,  92, (\)
		{0x00, 0x00, 0x41, 0x41, 0x7F, 0x00}, // Char 0x5D,  93, (])
		{0x00, 0x04, 0x02, 0x01, 0x02, 0x04}, // Char 0x5E,  94, (^)
		{0x80, 0x80, 0x80, 0x80, 0x80, 0x80}, // Char 0x5F,  95, (_)
		{0x00, 0x00, 0x01, 0x02, 0x00, 0x00}, // Char 0x60,  96, (`)
		{0x00, 0x20, 0x54, 0x54, 0x54, 0x78}, // Char 0x61,  97, (a)
		{0x00, 0x7F, 0x44, 0x44, 0x44, 0x38}, // Char 0x62,  98, (b)
		{0x00, 0x38, 0x44, 0x44, 0x44, 0x28}, // Char 0x63,  99, (c)
		{0x00, 0x38, 0x44, 0x44, 0x44, 0x7F}, // Char 0x64, 100, (d)
		{0x00, 0x38, 0x54, 0x54, 0x54, 0x18}, // Char 0x65, 101, (e)
		{0x00, 0x08, 0x7E, 0x09, 0x01, 0x02}, // Char 0x66, 102, (f)
		{0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C}, // Char 0x67, 103, (g)
		{0x00, 0x7F, 0x04, 0x04, 0x78, 0x00}, // Char 0x68, 104, (h)
		{0x00, 0x00, 0x44, 0x7D, 0x40, 0x00}, // Char 0x69, 105, (i)
		{0x00, 0x40, 0x80, 0x84, 0x7D, 0x00}, // Char 0x6A, 106, (j)
		{0x00, 0x7F, 0x10, 0x28, 0x44, 0x00}, // Char 0x6B, 107, (k)
		{0x00, 0x00, 0x41, 0x7F, 0x40, 0x00}, // Char 0x6C, 108, (l)
		{0x00, 0x7C, 0x04, 0x18, 0x04, 0x78}, // Char 0x6D, 109, (m)
		{0x00, 0x7C, 0x04, 0x04, 0x78, 0x00}, // Char 0x6E, 110, (n)
		{0x00, 0x38, 0x44, 0x44, 0x44, 0x38}, // Char 0x6F, 111, (o)
		{0x00, 0xFC, 0x44, 0x44, 0x44, 0x38}, // Char 0x70, 112, (p)
		{0x00, 0x38, 0x44, 0x44, 0x44, 0xFC}, // Char 0x71, 113, (q)
		{0x00, 0x44, 0x78, 0x44, 0x04, 0x08}, // Char 0x72, 114, (r)
		{0x00, 0x08, 0x54, 0x54, 0x54, 0x20}, // Char 0x73, 115, (s)
		{0x00, 0x04, 0x3E, 0x44, 0x24, 0x00}, // Char 0x74, 116, (t)
		{0x00, 0x3C, 0x40, 0x20, 0x7C, 0x00}, // Char 0x75, 117, (u)
		{0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C}, // Char 0x76, 118, (v)
		{0x00, 0x3C, 0x40, 0x20, 0x40, 0x3C}, // Char 0x77, 119, (w)
		{0x00, 0x6C, 0x10, 0x10, 0x6C, 0x00}, // Char 0x78, 120, (x)
		{0x00, 0x9C, 0xA0, 0x60, 0x3C, 0x00}, // Char 0x79, 121, (y)
		{0x00, 0x64, 0x54, 0x54, 0x4C, 0x00}, // Char 0x7A, 122, (z)
		{0x00, 0x08, 0x3E, 0x41, 0x41, 0x00}, // Char 0x7B, 123, ({)
		{0x00, 0x00, 0x00, 0x7F, 0x00, 0x00}, // Char 0x7C, 124, (|)
		{0x00, 0x00, 0x41, 0x41, 0x3E, 0x08}, // Char 0x7D, 125, (})
		{0x00, 0x00, 0x10, 0x08, 0x10, 0x08}, // Char 0x7E, 126, (~)
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x7F, 127
		{0x00, 0x14, 0x3E, 0x55, 0x55, 0x41}, // Char 0x80, 128, ()
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x81, 129
		{0x00, 0xE0, 0x60, 0x00, 0x00, 0x00}, // Char 0x82, 130, ()
		{0x00, 0x40, 0x88, 0x7E, 0x09, 0x02}, // Char 0x83, 131, ()
		{0x00, 0xE0, 0x60, 0x00, 0xE0, 0x60}, // Char 0x84, 132, ()
		{0x00, 0x40, 0x00, 0x40, 0x00, 0x40}, // Char 0x85, 133, ()
		{0x00, 0x04, 0x04, 0x7F, 0x04, 0x04}, // Char 0x86, 134, ()
		{0x00, 0x22, 0x22, 0x7F, 0x22, 0x22}, // Char 0x87, 135, ()
		{0x00, 0x00, 0x02, 0x01, 0x02, 0x00}, // Char 0x88, 136, ()
		{0x22, 0x35, 0x5A, 0x24, 0x52, 0x21}, // Char 0x89, 137, ()
		{0x00, 0x48, 0x55, 0x56, 0x55, 0x24}, // Char 0x8A, 138, ()
		{0x00, 0x00, 0x00, 0x08, 0x14, 0x00}, // Char 0x8B, 139, ()
		{0x00, 0x3E, 0x41, 0x7F, 0x49, 0x41}, // Char 0x8C, 140, ()
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x8D, 141
		{0x00, 0x44, 0x65, 0x56, 0x4D, 0x44}, // Char 0x8E, 142, ()
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x8F, 143
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x90, 144
		{0x00, 0x00, 0x07, 0x06, 0x00, 0x00}, // Char 0x91, 145, ()
		{0x00, 0x00, 0x03, 0x07, 0x00, 0x00}, // Char 0x92, 146, ()
		{0x00, 0x07, 0x06, 0x00, 0x07, 0x06}, // Char 0x93, 147, ()
		{0x00, 0x03, 0x07, 0x00, 0x03, 0x07}, // Char 0x94, 148, ()
		{0x00, 0x00, 0x08, 0x1C, 0x08, 0x00}, // Char 0x95, 149, ()
		{0x00, 0x08, 0x08, 0x08, 0x08, 0x08}, // Char 0x96, 150, ()
		{0x08, 0x08, 0x08, 0x08, 0x08, 0x08}, // Char 0x97, 151, ()
		{0x00, 0x00, 0x02, 0x01, 0x02, 0x01}, // Char 0x98, 152, ()
		{0x01, 0x07, 0x01, 0x07, 0x03, 0x07}, // Char 0x99, 153, ()
		{0x00, 0x08, 0x55, 0x56, 0x55, 0x20}, // Char 0x9A, 154, ()
		{0x00, 0x14, 0x08, 0x00, 0x00, 0x00}, // Char 0x9B, 155, ()
		{0x00, 0x38, 0x44, 0x7C, 0x54, 0x58}, // Char 0x9C, 156, ()
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0x9D, 157
		{0x00, 0x64, 0x55, 0x56, 0x4D, 0x00}, // Char 0x9E, 158, ()
		{0x00, 0x0C, 0x11, 0x60, 0x11, 0x0C}, // Char 0x9F, 159, ()
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Char 0xA0, 160
		{0x00, 0x00, 0x30, 0x7D, 0x30, 0x00}, // Char 0xA1, 161, (¡)
		{0x00, 0x18, 0x24, 0x66, 0x24, 0x00}, // Char 0xA2, 162, (¢)
		{0x00, 0x48, 0x3E, 0x49, 0x41, 0x62}, // Char 0xA3, 163, (£)
		{0x00, 0x22, 0x1C, 0x14, 0x1C, 0x22}, // Char 0xA4, 164, (¤)
		{0x00, 0x15, 0x16, 0x7C, 0x16, 0x15}, // Char 0xA5, 165, (¥)
		{0x00, 0x00, 0x00, 0x77, 0x00, 0x00}, // Char 0xA6, 166, (¦)
		{0x00, 0x22, 0x4D, 0x55, 0x59, 0x22}, // Char 0xA7, 167, (§)
		{0x00, 0x00, 0x01, 0x00, 0x01, 0x00}, // Char 0xA8, 168, (¨)
		{0x3E, 0x41, 0x5D, 0x55, 0x41, 0x3E}, // Char 0xA9, 169, (©)
		{0x00, 0x00, 0x02, 0x05, 0x06, 0x00}, // Char 0xAA, 170, (ª)
		{0x00, 0x08, 0x14, 0x00, 0x08, 0x14}, // Char 0xAB, 171, («)
		{0x04, 0x04, 0x04, 0x04, 0x04, 0x1C}, // Char 0xAC, 172, (¬)
		{0x00, 0x00, 0x08, 0x08, 0x08, 0x00}, // Char 0xAD, 173, (­)
		{0x3E, 0x41, 0x5D, 0x4B, 0x55, 0x3E}, // Char 0xAE, 174, (®)
		{0x00, 0x01, 0x01, 0x01, 0x01, 0x01}, // Char 0xAF, 175, (¯)
		{0x00, 0x00, 0x02, 0x05, 0x02, 0x00}, // Char 0xB0, 176, (°)
		{0x00, 0x48, 0x48, 0x7E, 0x48, 0x48}, // Char 0xB1, 177, (±)
		{0x00, 0x00, 0x09, 0x0D, 0x0A, 0x00}, // Char 0xB2, 178, (²)
		{0x00, 0x00, 0x11, 0x15, 0x0A, 0x00}, // Char 0xB3, 179, (³)
		{0x00, 0x00, 0x00, 0x02, 0x01, 0x00}, // Char 0xB4, 180, (´)
		{0x00, 0xFC, 0x40, 0x20, 0x7C, 0x00}, // Char 0xB5, 181, (µ)
		{0x00, 0x06, 0x09, 0x7F, 0x01, 0x7F}, // Char 0xB6, 182, (¶)
		{0x00, 0x00, 0x18, 0x18, 0x00, 0x00}, // Char 0xB7, 183, (·)
		{0x00, 0x00, 0x80, 0xC0, 0x00, 0x00}, // Char 0xB8, 184, (¸)
		{0x00, 0x00, 0x02, 0x0F, 0x00, 0x00}, // Char 0xB9, 185, (¹)
		{0x00, 0x00, 0x02, 0x05, 0x02, 0x00}, // Char 0xBA, 186, (º)
		{0x00, 0x14, 0x08, 0x00, 0x14, 0x08}, // Char 0xBB, 187, (»)
		{0x00, 0x17, 0x68, 0x54, 0xFA, 0x41}, // Char 0xBC, 188, (¼)
		{0x00, 0x17, 0x08, 0x94, 0xCA, 0xB1}, // Char 0xBD, 189, (½)
		{0x00, 0x15, 0x1F, 0x60, 0x50, 0xF8}, // Char 0xBE, 190, (¾)
		{0x00, 0x30, 0x48, 0x4D, 0x40, 0x20}, // Char 0xBF, 191, (¿)
		{0x00, 0x70, 0x29, 0x2A, 0x28, 0x70}, // Char 0xC0, 192, (À)
		{0x00, 0x70, 0x28, 0x2A, 0x29, 0x70}, // Char 0xC1, 193, (Á)
		{0x00, 0x70, 0x2A, 0x29, 0x2A, 0x70}, // Char 0xC2, 194, (Â)
		{0x00, 0x70, 0x2A, 0x29, 0x2A, 0x71}, // Char 0xC3, 195, (Ã)
		{0x00, 0x78, 0x25, 0x24, 0x25, 0x78}, // Char 0xC4, 196, (Ä)
		{0x00, 0x70, 0x2A, 0x2D, 0x2A, 0x70}, // Char 0xC5, 197, (Å)
		{0x00, 0x7E, 0x11, 0x7F, 0x49, 0x41}, // Char 0xC6, 198, (Æ)
		{0x00, 0x1E, 0xA1, 0xE1, 0x21, 0x12}, // Char 0xC7, 199, (Ç)
		{0x00, 0x7C, 0x55, 0x56, 0x54, 0x44}, // Char 0xC8, 200, (È)
		{0x00, 0x7C, 0x54, 0x56, 0x55, 0x44}, // Char 0xC9, 201, (É)
		{0x00, 0x7C, 0x56, 0x55, 0x56, 0x44}, // Char 0xCA, 202, (Ê)
		{0x00, 0x7C, 0x55, 0x54, 0x55, 0x44}, // Char 0xCB, 203, (Ë)
		{0x00, 0x00, 0x49, 0x7A, 0x48, 0x00}, // Char 0xCC, 204, (Ì)
		{0x00, 0x00, 0x48, 0x7A, 0x49, 0x00}, // Char 0xCD, 205, (Í)
		{0x00, 0x00, 0x4A, 0x79, 0x4A, 0x00}, // Char 0xCE, 206, (Î)
		{0x00, 0x00, 0x45, 0x7C, 0x45, 0x00}, // Char 0xCF, 207, (Ï)
		{0x00, 0x08, 0x7F, 0x49, 0x41, 0x3E}, // Char 0xD0, 208, (Ð)
		{0x00, 0x7C, 0x0A, 0x11, 0x22, 0x7D}, // Char 0xD1, 209, (Ñ)
		{0x00, 0x38, 0x45, 0x46, 0x44, 0x38}, // Char 0xD2, 210, (Ò)
		{0x00, 0x38, 0x44, 0x46, 0x45, 0x38}, // Char 0xD3, 211, (Ó)
		{0x00, 0x38, 0x46, 0x45, 0x46, 0x38}, // Char 0xD4, 212, (Ô)
		{0x00, 0x38, 0x46, 0x45, 0x46, 0x39}, // Char 0xD5, 213, (Õ)
		{0x00, 0x38, 0x45, 0x44, 0x45, 0x38}, // Char 0xD6, 214, (Ö)
		{0x00, 0x22, 0x14, 0x08, 0x14, 0x22}, // Char 0xD7, 215, (×)
		{0x00, 0x78, 0x64, 0x54, 0x4C, 0x3C}, // Char 0xD8, 216, (Ø)
		{0x00, 0x3C, 0x41, 0x42, 0x40, 0x3C}, // Char 0xD9, 217, (Ù)
		{0x00, 0x3C, 0x40, 0x42, 0x41, 0x3C}, // Char 0xDA, 218, (Ú)
		{0x00, 0x38, 0x42, 0x41, 0x42, 0x38}, // Char 0xDB, 219, (Û)
		{0x00, 0x3C, 0x41, 0x40, 0x41, 0x3C}, // Char 0xDC, 220, (Ü)
		{0x00, 0x0C, 0x10, 0x62, 0x11, 0x0C}, // Char 0xDD, 221, (Ý)
		{0x00, 0xFF, 0xA5, 0x24, 0x18, 0x00}, // Char 0xDE, 222, (Þ)
		{0x00, 0x7E, 0x01, 0x49, 0x4E, 0x30}, // Char 0xDF, 223, (ß)
		{0x00, 0x30, 0x49, 0x4A, 0x48, 0x78}, // Char 0xE0, 224, (à)
		{0x00, 0x30, 0x48, 0x4A, 0x49, 0x78}, // Char 0xE1, 225, (á)
		{0x00, 0x30, 0x4A, 0x49, 0x4A, 0x78}, // Char 0xE2, 226, (â)
		{0x00, 0x30, 0x4A, 0x49, 0x4A, 0x79}, // Char 0xE3, 227, (ã)
		{0x00, 0x20, 0x55, 0x54, 0x55, 0x78}, // Char 0xE4, 228, (ä)
		{0x00, 0x30, 0x4A, 0x4D, 0x4A, 0x78}, // Char 0xE5, 229, (å)
		{0x00, 0x24, 0x54, 0x7C, 0x54, 0x58}, // Char 0xE6, 230, (æ)
		{0x00, 0x1C, 0xA2, 0xE2, 0x22, 0x14}, // Char 0xE7, 231, (ç)
		{0x00, 0x38, 0x55, 0x56, 0x54, 0x18}, // Char 0xE8, 232, (è)
		{0x00, 0x38, 0x54, 0x56, 0x55, 0x18}, // Char 0xE9, 233, (é)
		{0x00, 0x38, 0x56, 0x55, 0x56, 0x18}, // Char 0xEA, 234, (ê)
		{0x00, 0x38, 0x55, 0x54, 0x55, 0x18}, // Char 0xEB, 235, (ë)
		{0x00, 0x00, 0x49, 0x7A, 0x40, 0x00}, // Char 0xEC, 236, (ì)
		{0x00, 0x00, 0x48, 0x7A, 0x41, 0x00}, // Char 0xED, 237, (í)
		{0x00, 0x00, 0x4A, 0x79, 0x42, 0x00}, // Char 0xEE, 238, (î)
		{0x00, 0x00, 0x45, 0x7C, 0x41, 0x00}, // Char 0xEF, 239, (ï)
		{0x00, 0x35, 0x4A, 0x4D, 0x38, 0x00}, // Char 0xF0, 240, (ð)
		{0x00, 0x7A, 0x09, 0x0A, 0x71, 0x00}, // Char 0xF1, 241, (ñ)
		{0x00, 0x30, 0x49, 0x4A, 0x48, 0x30}, // Char 0xF2, 242, (ò)
		{0x00, 0x30, 0x48, 0x4A, 0x49, 0x30}, // Char 0xF3, 243, (ó)
		{0x00, 0x30, 0x4A, 0x49, 0x4A, 0x30}, // Char 0xF4, 244, (ô)
		{0x00, 0x30, 0x4A, 0x49, 0x4A, 0x31}, // Char 0xF5, 245, (õ)
		{0x00, 0x30, 0x4A, 0x48, 0x4A, 0x30}, // Char 0xF6, 246, (ö)
		{0x00, 0x08, 0x08, 0x2A, 0x08, 0x08}, // Char 0xF7, 247, (÷)
		{0x00, 0x70, 0x68, 0x58, 0x38, 0x00}, // Char 0xF8, 248, (ø)
		{0x00, 0x38, 0x41, 0x22, 0x78, 0x00}, // Char 0xF9, 249, (ù)
		{0x00, 0x38, 0x42, 0x21, 0x78, 0x00}, // Char 0xFA, 250, (ú)
		{0x00, 0x38, 0x42, 0x21, 0x7A, 0x00}, // Char 0xFB, 251, (û)
		{0x00, 0x3C, 0x41, 0x20, 0x7D, 0x00}, // Char 0xFC, 252, (ü)
		{0x00, 0x9C, 0xA2, 0x61, 0x3C, 0x00}, // Char 0xFD, 253, (ý)
		{0x00, 0xFE, 0xAA, 0x28, 0x10, 0x00}, // Char 0xFE, 254, (þ)
		{0x00, 0x9C, 0xA1, 0x60, 0x3D, 0x00}  // Char 0xFF, 255, (ÿ)
};
// Splash screen frame buffer (128x64 = 1024 bytes)
// Original NXP logo removed - use fillOLED() or text display on startup
uint8_t frame[1024] = {0};  // Initialize to blank screen

void sendOLED(uint8_t* buffer, uint16_t size, uint8_t CD)
{
	LPI2C_MasterStart(I2C_OLED, OLED_ADDRESS, kLPI2C_Write);
	LPI2C_MasterSend(I2C_OLED, &CD, 1);
	LPI2C_MasterSend(I2C_OLED, buffer, size);
	LPI2C_MasterStop(I2C_OLED);
}

void initOLED()
{
	//add delay
	uint8_t init[27] =
	{
		0xAE,   // display off
		0xD5,   // (1/2) clock divide ratio (0x00=1) and oscillator frequency (0x8)
		0x80,   // (2/2) clock divide ratio (0x00=1) and oscillator frequency (0x8)
		0xA8,   // (1/2) multiplex ratio
		0x3F,   // (2/2) multiplex ratio
		0xD3,   // (1/2) display offset
		0x00,   // (2/2) display offset
		0x40,   // set display start line to 0
		0x8D,   // (1/2) [2] charge pump setting (p62): 0x014 enable, 0x010 disable, SSD1306 only, should be removed for SH1106
		0x14,   // (2/2) [2] charge pump setting (p62): 0x014 enable, 0x010 disable, SSD1306 only, should be removed for SH1106
		0x20,   // (1/2) horizontal addressing mode
		0x00,   // (2/2) horizontal addressing mode
		0xA1,   // segment remap a0/a1
		0xC8,   // c0: scan dir normal, c8: reverse
		0xDA,   // (1/2) com pin HW config, sequential com pin config (bit 4), disable left/right remap (bit 5)
		0x12,   // (2/2) com pin HW config, sequential com pin config (bit 4), disable left/right remap (bit 5)
		0x81,   // (1/2) [2] set contrast control
		0xCF,   // (2/2) [2] set contrast control
		0xD9,   // (1/2) [2] pre-charge period 0x022/f1
		0xF1,   // (2/2) [2] pre-charge period 0x022/f1
		0xDB,   // (1/2) vcomh deselect level
		0x30,   // (2/2) vcomh deselect level
		0x2E,   // Deactivate scroll
		0xA4,   // output ram to display
		0xA6,   // normal display mode
		0xAF    // display on
	};

	lpi2c_master_config_t sMasterConfig = {0};
	LPI2C_MasterGetDefaultConfig(&sMasterConfig);
	LPI2C_MasterInit(I2C_OLED, &sMasterConfig, LPI2C_MASTER_CLOCK_FREQUENCY);
	sendOLED(init, 27, OLED_COMMAND);

	setPage(0);
	setSeg(0);
	fillOLED(0x00);
}

void printfOLED(const char* format, ...)
{
	bool invert = 0;
	va_list arg_ptr;
	va_start(arg_ptr, format);
	uint8_t buffLen = vsnprintf(NULL, 0, format, arg_ptr) + 1; // get formatted string length from vsnprintf by making it fail
	char buffer[buffLen]; // create character array for formatted string
	//memset(buffer, 0, buffLen * sizeof(char));
	vsprintf(buffer, format, arg_ptr); // store formatted string in array
	va_end(arg_ptr);
	for(uint32_t strChar = 0; buffer[strChar] != '\0'; strChar++)
	{
		lineWrap(); // check if line has reached end of screen
		switch(buffer[strChar])
		{
			case '\n':
				currCharLoc[0] = 21; // set cursor to end of screen to trigger line wrapping
				break;
			case '\x1b':
				if(buffer[strChar + 1] == '[')
				{
					while(buffer[strChar] != 'm')
					{
						strChar++;
					}
					if(buffer[strChar - 1] == '7' && buffer[strChar] == 'm')
					{
						invert = 1;
					}
					if(buffer[strChar - 2] == '2' && buffer[strChar - 1] == '7' && buffer[strChar] == 'm')
					{
						invert = 0;
					}
				}
				break;
			default:
				writeChar(buffer[strChar], invert); // write character to display
				currCharLoc[0]++; // increment cursor
				break;
		}
	}
} /* printfLCD() */

/** -----------------------------------------------------------------------------------------------
 @brief      Draws a 6×8 pixel character from the font array, whose ASCII code corresponds to its
 	 	 	 position in the array.

 @param[in]  uint8_t character: The ASCII character to be drawn. (0x00-0xFF)
 @param[in]  bool inverted: Inverts the drawn pixels. 0 = black on white, 1 = white on black.
-------------------------------------------------------------------------------------------------*/
void writeChar(uint8_t character, bool inverted)
{
	//TODO: fix inverted
	sendOLED((uint8_t*)(&font[character][0]), 6, OLED_DATA); // write char with ASCII code 'character' from the font array
} /* writeChar() */

/** -----------------------------------------------------------------------------------------------
 @brief      Sets the current page for bytes to be drawn to.

 @param[in]  uint8_t page: The selected page. (0-7)
-------------------------------------------------------------------------------------------------*/
void setPage(uint8_t page)
{
	uint8_t pageCommand = 0xB0 + page;
	sendOLED(&pageCommand, 1, OLED_COMMAND);
} /* setPage() */

/** -----------------------------------------------------------------------------------------------
 @brief      Sets the horizontal position of the current segment.

 @param[in]  uint8_t seg: The segment to which the position is set. (0-101)
-------------------------------------------------------------------------------------------------*/
void setSeg(uint8_t seg)
{
	uint8_t segCommand[2] = {0x00 | (seg & 0x0F), 0x10 | ((seg & 0xF0) >> 4)};
	sendOLED(segCommand, 2, OLED_COMMAND);
} /* setSeg() */

/** -----------------------------------------------------------------------------------------------
 @brief      Fill each byte of the display RAM with a given byte. 0x00 corresponds to all black
 	 	 	 pixels, 0xFF corresponds to all white pixels.

 @param[in]  uint8_t data: The byte to be used to fill the display RAM. (0x00-0xFF)
-------------------------------------------------------------------------------------------------*/
void fillOLED(uint8_t data)
{
	uint8_t frame[1024];
	for(uint16_t seg = 0; seg < 1024; seg++)
	{
		frame[seg] = data;
	}
	setPage(0);
	setSeg(0);
	sendOLED(frame, 1024, OLED_DATA);
} /* fillOLED() */

/** -----------------------------------------------------------------------------------------------
 @brief      Prints out a string of characters from the font array on a chosen page. To be used
 	 	 	 instead of printfLCD() when used with other graphical functions such as drawVLine().

 @param[in]  char *string: The array of characters to be drawn as a string.
 @param[in]  bool inverted: Inverts the drawn pixels. 0 = black on white, 1 = white on black.
 @param[in]  uint8_t seg: Sets the segment from which the string is drawn. (0-101)
 @param[in]  uint8_t seg: Sets the page on which the string is drawn. (0-7)
-------------------------------------------------------------------------------------------------*/
void writeString(char *string, bool inverted, uint8_t seg, uint8_t page)
{
	setPage(page);
	setSeg(seg);
	uint8_t len = min((OLED_WIDTH - seg)/6, strlen(string)); // draw string chars until LCD edge or string done
	uint8_t strPos = 0;

	for(strPos = 0; strPos < len; strPos++)
	{
		writeChar(string[strPos], inverted);
	}
} /* writeString() */

/** -----------------------------------------------------------------------------------------------
 @brief      Line-wrap a string of characters to fit on the display, scrolling the display when
 	 	 	 needed.
-------------------------------------------------------------------------------------------------*/
void lineWrap(void)
{
	if(currCharLoc[0] == 21)
	{
		currCharLoc[0] = 0; // set the cursor location to the beginning of the line
		currCharLoc[1]++; // place the cursor on the next line
		setPage(currCharLoc[1] % 8); // only 8 pages, so set page to remainder of line division by 8
		/*
		 * To not overflow currCharLoc, it is reset to 8 every time it reaches 16. When the line
		 * number is between 0 and 7, it corresponds to each of 8 pages on the display, from top to
		 * bottom. When the line number is between 8 and 15, it instead corresponds to each of the
		 * 8 scrolled screen configurations, with the cursor on the bottom-most page. E.g., when
		 * the line number is 6, the cursor is on page 6, with page 0 being at the top of the
		 * screen and page 7 at the bottom. When the line number is 11, the cursor is on line 3
		 * (11 % 8), with page 4 being at the top and page 3 at the bottom.
		 */
		if(currCharLoc[1] == 16)
		{
			currCharLoc[1] = 8;
		}
		fillPage(0x00);
		setPage(currCharLoc[1] % 8); //repeat in case segment has incremented to next page
		setSeg(0);


	}
	if(currCharLoc[1] > 7)
	{
		scrollOLED(((currCharLoc[1] + 1) % 8) * 8); // set the scroll line at top of page to current page +1
	}
} /* lineWrap() */

/** -----------------------------------------------------------------------------------------------
 @brief      Prints out an encoded representation of a variable's value. Intended to be used
 	 	 	 alongside writeString() for graphical purposes, instead of printf(). The output does
 	 	 	 not advance the cursor, instead updating the currently drawn character(s).

 @param[in]  char* formatting: printf-compatible format specifier to encode and format the variable
 @param[in]  int32_t var: The variable whose value is to be printed out.
 @param[in]  bool inverted: Inverts the drawn pixels. 0 = white on black, 1 = black on white.
 @param[in]  uint8_t seg: Sets the segment from which the variable is drawn. (0-127)
 @param[in]  uint8_t page: Sets the page on which the variable is drawn. (0-7)
-------------------------------------------------------------------------------------------------*/
void printVar(char* formatting, int32_t var, bool inverted, uint8_t seg, uint8_t page)
{
	char pageBuffer[21];
	sprintf(pageBuffer, formatting, var);
	writeString(pageBuffer, inverted, seg, page);
} /* printVar() */

/** -----------------------------------------------------------------------------------------------
 @brief      Fill each byte of the display RAM with 0x00, reset scroll line to 0, and reset cursor
 	 	 	 locations.
-------------------------------------------------------------------------------------------------*/
void resetOLED(void)
{
	fillOLED(0);
	scrollOLED(0);
	currCharLoc[0] = 0;
	currCharLoc[1] = 0;
	setPage(0);
	setSeg(0);

} /* resetOLED() */

/** -----------------------------------------------------------------------------------------------
 @brief      Fill each byte of the current page's display RAM with a given byte. 0x00 corresponds
 	 	 	 to all blank pixels, 0xFF corresponds to all black pixels.

 @param[in]  uint8_t data: The byte to be used to write to display RAM. (0x00-0xFF)
-------------------------------------------------------------------------------------------------*/
void fillPage(uint8_t data)
{
	uint8_t page[128];
	for(uint16_t seg = 0; seg < 128; seg++)
	{
		page[seg] = data;
	}
	setSeg(0);
	sendOLED(page, 128, OLED_DATA);
} /* fillPage() */

/** -----------------------------------------------------------------------------------------------
 @brief      Scroll the entire display by a number of pixel rows.

 @param[in]  uint8_t rows: Number of rows to scroll (0-64)
-------------------------------------------------------------------------------------------------*/
void scrollOLED(uint8_t rows)
{
	uint8_t scrollCommand[2] = {0xD3, rows};
	sendOLED(scrollCommand, 2, OLED_COMMAND);
} /* scrollOLED() */

/** -----------------------------------------------------------------------------------------------
 @brief      Compares two numbers and returns the smaller of the two.

 @param[in]  uint8_t num1: First number to evaluate. (0-255)
 @param[in]  uint8_t num2: Second number to evaluate. (0-255)

 @return     Smallest of num1 and num2. (0-255)
-------------------------------------------------------------------------------------------------*/
uint8_t min(uint8_t num1, uint8_t num2)
{
	return (num1 > num2) ? num2 : num1; // if expression true, evaluate to num2, else evaluate to num1
} /* min() */

/** -----------------------------------------------------------------------------------------------
 @brief      Compares two numbers and returns the larger of the two.

 @param[in]  uint8_t num1: First number to evaluate. (0-255)
 @param[in]  uint8_t num2: Second number to evaluate. (0-255)

 @return     Largest of num1 and num2. (0-255)
-------------------------------------------------------------------------------------------------*/
uint8_t max(uint8_t num1, uint8_t num2)
{
	return (num1 > num2) ? num1 : num2; // if expression true, evaluate to num2, else evaluate to num1
} /* max() */

/** -----------------------------------------------------------------------------------------------
 @brief      Prints out a range of characters from the font array in 'lcdbitmaps.c'. Usage in
 	 	 	 conjunction with other functions that draw to the LCD is discouraged -- it will likely
 	 	 	 produce undesirable results.

 @param[in]  uint8_t startChar: The first character in the range to print out.
 @param[in]  uint8_t endChar: The last character in the range to print out.
-------------------------------------------------------------------------------------------------*/
void testFont(uint8_t startChar, uint8_t endChar)
{
	uint16_t currChar = 0;
	fillOLED(0x00);
	setPage(0);
	setSeg(0);
	for(currChar = startChar; currChar < endChar; currChar++)
	{
		printfOLED("%c", currChar);
	}
} /* writeChar() */
